---
// TableOfContents.astro - 文章目录组件
// 支持层级嵌套和折叠展开
const { class: className = '' } = Astro.props;
---

<aside id="toc-container" class:list={[className, 'toc-container']}>
  <!-- 移动端切换按钮 -->
  <button id="toc-toggle" class="toc-toggle" aria-label="切换目录">
    <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor">
      <path stroke-linecap="round" stroke-linejoin="round" d="M3.75 6.75h16.5M3.75 12h16.5m-16.5 5.25h16.5" />
    </svg>
  </button>

  <!-- 目录导航 -->
  <nav id="toc-nav" class="toc-nav">
    <div class="toc-header">
      <h3>
        <svg xmlns="http://www.w3.org/2000/svg" class="w-4 h-4" fill="none" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor">
          <path stroke-linecap="round" stroke-linejoin="round" d="M8.25 6.75h12M8.25 12h12m-12 5.25h12M3.75 6.75h.007v.008H3.75V6.75Zm.007 12.25h.007v.008h-.007V18.75Z" />
        </svg>
        目录
      </h3>
      <button id="toc-close" aria-label="关闭目录">&times;</button>
    </div>
    <ul id="toc-list" class="toc-list"></ul>
  </nav>
</aside>

<script>
  document.addEventListener('DOMContentLoaded', () => {
    const prose = document.querySelector('.prose');
    const tocContainer = document.getElementById('toc-container');
    const tocList = document.getElementById('toc-list');
    const tocNav = document.getElementById('toc-nav');
    const tocToggle = document.getElementById('toc-toggle');
    const tocClose = document.getElementById('toc-close');

    if (!prose || !tocContainer || !tocList || !tocNav) return;

    type HeadingData = { id: string; text: string; level: number; element: Element; children?: HeadingData[] };

    const extractHeadings = (): HeadingData[] => {
      const headings = prose.querySelectorAll('h2, h3');
      const result: HeadingData[] = [];
      let currentH2: HeadingData | null = null;

      headings.forEach((heading, index) => {
        const id = `heading-${index}`;
        (heading as HTMLElement).id = id;

        const level = parseInt(heading.tagName.charAt(1));
        const item: HeadingData = {
          id,
          text: heading.textContent?.trim() || '',
          level,
          element: heading,
          children: []
        };

        if (level === 2) {
          result.push(item);
          currentH2 = item;
        } else if (level === 3 && currentH2) {
          currentH2.children!.push(item);
        }
      });

      return result;
    };

    const renderToc = (headings: HeadingData[]) => {
      if (headings.length === 0) {
        // 不需要手动隐藏，由外部传入的类控制
        return;
      }

      const renderHeading = (item: HeadingData): string => {
        const hasChildren = item.children && item.children.length > 0;
        const childrenHtml = hasChildren
          ? `<ul class="toc-sublist">${item.children!.map(sub => renderHeading(sub)).join('')}</ul>`
          : '';

        return `
          <li class="toc-item toc-level-${item.level}" data-heading="${item.id}">
            <div class="toc-link-wrapper">
              ${hasChildren ? `
                <button class="toc-toggle-btn" aria-label="切换子目录" data-heading="${item.id}">
                  <svg class="toc-chevron" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="2.5" stroke="currentColor">
                    <path stroke-linecap="round" stroke-linejoin="round" d="M19.5 8.25l-7.5 7.5-7.5-7.5" />
                  </svg>
                </button>
              ` : '<span class="toc-spacer"></span>'}
              <a href="#${item.id}" class="toc-link" data-target="${item.id}">${item.text}</a>
            </div>
            ${childrenHtml}
          </li>
        `;
      };

      tocList.innerHTML = headings.map(h => renderHeading(h)).join('');
    };

    const setupCollapse = () => {
      document.querySelectorAll('.toc-toggle-btn').forEach(btn => {
        btn.addEventListener('click', (e) => {
          e.preventDefault();
          e.stopPropagation();

          const headingId = btn.getAttribute('data-heading');
          const parentLi = document.querySelector(`.toc-item[data-heading="${headingId}"]`);
          const sublist = parentLi?.querySelector(':scope > .toc-sublist') as HTMLElement;
          const chevron = btn.querySelector('.toc-chevron') as HTMLElement;

          if (sublist) {
            const isCollapsed = sublist.style.display === 'none';
            sublist.style.display = isCollapsed ? 'block' : 'none';
            if (chevron) chevron.style.transform = isCollapsed ? 'rotate(0deg)' : 'rotate(-90deg)';
            parentLi?.classList.toggle('collapsed', !isCollapsed);
          }
        });
      });
    };

    const setupSmoothScroll = () => {
      const offset = 100;

      document.querySelectorAll('.toc-link').forEach(link => {
        link.addEventListener('click', (e) => {
          e.preventDefault();
          const targetId = link.getAttribute('data-target');
          if (!targetId) return;

          const targetElement = document.getElementById(targetId);
          if (!targetElement) return;

          const targetPosition = targetElement.getBoundingClientRect().top + window.scrollY - offset;

          window.scrollTo({
            top: targetPosition,
            behavior: 'smooth'
          });

          history.replaceState(null, '', `#${targetId}`);

          if (window.innerWidth < 1024) {
            tocNav.classList.remove('open');
          }
        });
      });
    };

    const setupScrollSpy = () => {
      const headings = prose.querySelectorAll('h2, h3');

      const observer = new IntersectionObserver((entries) => {
        entries.forEach(entry => {
          if (entry.isIntersecting) {
            const id = entry.target.id;

            document.querySelectorAll('.toc-link').forEach(link => {
              link.classList.remove('active');
            });

            const activeLink = document.querySelector(`.toc-link[data-target="${id}"]`) as HTMLElement;
            activeLink?.classList.add('active');
          }
        });
      }, { rootMargin: '-100px 0px -66%', threshold: 0 });

      headings.forEach(heading => observer.observe(heading));
    };

    const setupMobileToggle = () => {
      if (!tocToggle || !tocClose) return;

      tocToggle.addEventListener('click', () => tocNav.classList.add('open'));
      tocClose.addEventListener('click', () => tocNav.classList.remove('open'));

      document.addEventListener('click', (e) => {
        if (tocContainer && !tocContainer.contains(e.target as Node)) {
          tocNav.classList.remove('open');
        }
      });
    };

    const headings = extractHeadings();
    renderToc(headings);

    if (headings.length > 0) {
      setupCollapse();
      setupSmoothScroll();
      setupScrollSpy();
      setupMobileToggle();
    }
  });
</script>

<style>
  /* 桌面端：使用 sticky 定位 */
  .toc-container {
    width: 100%;
    position: sticky;
  }

  .toc-container.hidden {
    display: none;
  }

  /* 移动端切换按钮 */
  .toc-toggle {
    display: none;
    align-items: center;
    justify-content: center;
    width: 48px;
    height: 48px;
    border-radius: 50%;
    background: rgba(255, 255, 255, 0.9);
    backdrop-filter: blur(12px);
    border: 1px solid rgba(255, 255, 255, 0.5);
    box-shadow: 0 8px 24px -8px rgba(0, 0, 0, 0.1);
    cursor: pointer;
    color: #475569;
  }

  .toc-toggle:hover {
    transform: scale(1.05);
    box-shadow: 0 12px 32px -8px rgba(59, 130, 246, 0.2);
  }

  .toc-nav {
    background: rgba(255, 255, 255, 0.7);
    backdrop-filter: blur(24px);
    border: 1px solid rgba(255, 255, 255, 0.5);
    border-radius: 1.5rem;
    box-shadow: 0 20px 40px -12px rgba(59, 130, 246, 0.1);
    padding: 1.5rem;
    max-height: calc(100vh - 140px);
    overflow-y: auto;
    scrollbar-width: none;
  }

  .toc-nav::-webkit-scrollbar {
    display: none;
  }

  .toc-header {
    display: flex;
    align-items: center;
    justify-content: space-between;
    margin-bottom: 1rem;
  }

  .toc-header h3 {
    display: flex;
    align-items: center;
    gap: 0.5rem;
    font-size: 0.75rem;
    font-weight: 900;
    text-transform: uppercase;
    letter-spacing: 0.2em;
    color: #94a3b8;
    margin: 0;
  }

  #toc-close {
    display: none;
    width: 32px;
    height: 32px;
    border: none;
    background: rgba(148, 163, 184, 0.1);
    border-radius: 50%;
    cursor: pointer;
    font-size: 1.5rem;
    line-height: 1;
    color: #64748b;
  }

  #toc-close:hover {
    background: rgba(239, 68, 68, 0.1);
    color: #ef4444;
  }

  .toc-list {
    list-style: none;
    margin: 0;
    padding: 0;
  }

  .toc-sublist {
    list-style: none;
    margin: 0;
    padding-left: 0;
  }

  .toc-item {
    margin-bottom: 0.25rem;
  }

  .toc-link-wrapper {
    display: flex;
    align-items: center;
    gap: 0.25rem;
  }

  .toc-toggle-btn {
    display: flex;
    align-items: center;
    justify-content: center;
    width: 20px;
    height: 20px;
    flex-shrink: 0;
    border: none;
    background: transparent;
    cursor: pointer;
    padding: 0;
    color: #94a3b8;
  }

  .toc-toggle-btn:hover {
    color: #3b82f6;
  }

  .toc-chevron {
    width: 14px;
    height: 14px;
    transition: transform 0.3s;
  }

  .toc-item.collapsed .toc-chevron {
    transform: rotate(-90deg);
  }

  .toc-spacer {
    width: 20px;
    flex-shrink: 0;
  }

  .toc-level-2 > .toc-link-wrapper > .toc-link {
    font-size: 0.875rem;
    font-weight: 700;
    color: #475569;
    padding: 0.5rem 0.75rem;
    display: block;
    border-radius: 0.5rem;
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
    flex: 1;
  }

  .toc-level-2 > .toc-link-wrapper > .toc-link:hover {
    background: rgba(59, 130, 246, 0.08);
    color: #2563eb;
  }

  .toc-level-3 {
    margin-top: 0.25rem;
  }

  .toc-level-3 > .toc-link-wrapper > .toc-link {
    font-size: 0.8125rem;
    font-weight: 500;
    color: #64748b;
    padding: 0.375rem 0.75rem 0.375rem 2rem;
    display: block;
    border-radius: 0.5rem;
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
    flex: 1;
  }

  .toc-level-3 > .toc-link-wrapper > .toc-link:hover {
    color: #3b82f6;
  }

  .toc-link.active {
    background: linear-gradient(135deg, rgba(59, 130, 246, 0.12), rgba(6, 182, 212, 0.08));
    color: #2563eb;
    font-weight: 800;
  }

  @media (max-width: 1023px) {
    /* 移动端：恢复 fixed 定位实现弹出效果 */
    .toc-container {
      position: fixed;
      top: 70px;
      left: 0;
      right: 0;
      width: 100%;
      max-height: none;
      z-index: 40;
    }

    .toc-toggle {
      display: flex;
      position: fixed;
      top: 80px;
      right: 16px;
      z-index: 41;
    }

    .toc-nav {
      position: absolute;
      top: 0;
      right: 0;
      width: calc(100% - 32px);
      max-width: 320px;
      max-height: calc(100vh - 100px);
      margin: 16px;
      opacity: 0;
      visibility: hidden;
      transform: translateX(20px);
      transition: all 0.3s;
    }

    .toc-nav.open {
      opacity: 1;
      visibility: visible;
      transform: translateX(0);
    }

    #toc-close {
      display: block;
      position: absolute;
      top: 1rem;
      right: 1rem;
    }
  }

  @media print {
    .toc-container {
      display: none !important;
    }
  }

  :global(.prose h2),
  :global(.prose h3),
  :global(.prose h4),
  :global(.prose h5),
  :global(.prose h6) {
    scroll-margin-top: 100px;
  }
</style>
